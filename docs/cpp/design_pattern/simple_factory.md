# 简单工厂模式

创建型模式关注对象的创建过程，描述如何将对象的创建和使用分离，对象使用过程中无需关心对象的创建细节，降低系统耦合度，并且让系统易于修改和扩展。

简单工厂模式是最简单的设计模式之一，应用频繁，也是其余创建模式的基础。

## 简单工厂应用举例

一个工厂 Factory，可以根据客户需求生成各种产品。客户需要向工厂提供产品参数，工厂根据产品参数生产对应产品，客户不需要关心生产细节。

由此可总结出简单工厂的基本实现流程：

- 设计一个抽象产品类，包含一些公共方法的实现；
- 从抽象产品类派生出多个具体产品类；
- 设计一个工厂类，工厂类中提供了一个生产各种产品的工厂方法，该方法根据传入参数创建不同的具体产品类对象；
- 客户只需调用工厂类的工厂方法，并传入具体产品参数，即可得到一个具体产品对象。

### 简单工厂定义

定义一个简单工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。

## 简单工厂模式结构

在简单工厂模式中，大体上有 3 个角色：

- 工厂 Factory：根据客户提供的产品类的参数，创建具体产品实例；
- 抽象产品 AbstractProduct：具体产品类的基类，包括创建产品的公共方法；
- 具体产品 ConcreteProduct：抽象产品的派生类，包含具体产品特有的实现方法，是简单工厂模式的创建目标。

![简单工厂模式](simple_factory.png)

代码结构如下：

```c++
//抽象产品类AbstractProduct
class AbstractProduct {
public:
	//抽象方法：
};
 
//具体产品类 ConcreteProduct
class ConcreteProduct :public AbstractProduct {
public:
	//具体实现方法
};
 
class Factory {
public:
	AbstractProduct createProduct(string productName) {
		AbstractProduct pro = NULL;
		if (productName == "ProductA") {
			pro = new ProductA();
		}
		else if (productName == "ProductB") {
			pro = new ProductB();
		}
		...
	}
};
```

## 总结

简单工厂模式的优点在于：

- 工厂类提供创建具体产品的方法，并包含一定判断逻辑，客户不必参加产品的创建过程；
- 客户只需指导对应产品的参数即可。

当然，简单工厂模式存在明显的不足。添加产品需要新增一个派生类，并在工厂类中添加对应的分支。但这明显违背了开闭原则，即扩展功能时修改了既有的代码。另一方面，所有逻辑判断在工厂类中实现，一旦工厂类设计故障，整个系统都受之影响。