## 对标准库的扩充：正则表达式

### 正则表达式简介

正则表达式不是 C++ 语言的一部分，仅做简单介绍。

正则表达式描述了一种字符串匹配的模式。一般使用正则表达式主要是实现下面三个需求：

1. 检测一个串是否包括某种形式的子串；
2. 将匹配的字串替换；
3. 从某个串中取出符合条件的子串。

正则表达式是由普通字符以及特殊字符组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。

#### 普通字符

普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。包括所有大小写字母、所有数字、所有标点符号和一些其他符号。

#### 特殊字符

特殊字符是正则表达式中有特殊含义的字符，也是正则表达式的核心匹配语法。

| 特殊字符 | 描述                                                                   |
| -------- | ---------------------------------------------------------------------- |
| `$`      | 匹配结尾                                                               |
| `(` `)`  | 标记一个子表达式开始和结束位置。                                       |
| `*`      | 匹配前面的子表达式零次或多次。                                         |
| `+`      | 匹配前面的子表达式一次或多次。                                         |
| `.`      | 匹配换行符 `\n` 之外的任何单字符。                                     |
| `[`      | 标记中括号表达式的开始。                                               |
| `?`      | 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。                 |
| `\`      | 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。 |
| `^`      | 匹配输入字符串的开始位置，除非在方括号表达式中，表示不接受该字符集。   |
| `{`      | 标记限定符表达式的开始。                                               |
| `|`      | 指明两项之间的选择。                                                   |

#### 限定符

限定符用来指定正则表达式的一个给定的组键必须要出现多少次才能满足匹配。

| 字符    | 描述                          |
| ------- | ----------------------------- |
| `{n}`   | 非负整数 n，匹配确定的 n 次。 |
| `{n,}`  | 至少匹配 n 次。               |
| `{n,m}` | 匹配 n 到 m 次。              |
| `*`     | 相当于 `{0,}`。               |
| `+`     | 相当于 `{1,}`。               |
| `?`     | 相当于 `{0,1}`。              |

### std::regex

传统 C++ 中正则表达式未纳入标准库。一般都是用 `boost` 的正则库。

C++11 正式将正则表达式的处理纳入标准库的行列，从语言级上提供了标准的支持。

C++11 提供的正则表达式库操作 `std::string` 对象，模式 `std::regex`（本质是 `std::basic_regex`) 进行初始化，通过 `std::regex_match` 匹配，从而产生 `std::smatch`（本质是 `std::match_results` 对象）。

考虑以下的正则表达式：

`[a-z]+\.txt`，匹配纯小写字母组成的文本文件。

`std::regex_match` 用于匹配字符串和正则表达式，有很多不同的重载形式。最简单的形式就是传入 `std::string` 以及一个 `std::regex` 进行匹配，成功返回 `true`，否则返回 `false`。

```c++
#include <iostream>
#include <string>
#include <regex>

int main() {
    std::string fnames[] = {"foo.txt", "bar.txt", "test", "a0.txt", "AAA.txt"};
    // 在 C++ 中 `\` 会被作为字符串内的转义符，为使 `\.` 作为正则表达式传递进去生效，需要对 `\` 进行二次转义，从而有 `\\.`
    std::regex txt_regex("[a-z]+\\.txt");
    for (const auto &fname: fnames)
        std::cout << fname << ": " << std::regex_match(fname, txt_regex) << std::endl;
}
```

另一种常用的形式就是依次传入 `std::string, std::smatch, std::regex` 参数，其中 `std::smatch` 本质就是 `std::match_results`。标准库中，定义为 `std::match_results<std::string::const_iterator>`，也就是一个子串迭代器类型的 `match_results`。使用 `std::smatch` 可以方便的对匹配的结果进行获取：

```c++
std::regex base_regex("([a-z]+)\\.txt");
std::smatch base_match;
for(const auto &fname: fnames) {
    if (std::regex_match(fname, base_match, base_regex)) {
        // sub_match 的第一个元素匹配整个字符串
        // sub_match 的第二个元素匹配了第一个括号表达式
        if (base_match.size() == 2) {
            std::string base = base_match[1].str();
            std::cout << "sub-match[0]: " << base_match[0].str() << std::endl;
            std::cout << fname << " sub-match[1]: " << base << std::endl;
        }
    }
}
```

### 总结

本节简单介绍了正则表达式本身，然后根据使用正则表达式的主要需求，通过实例介绍了正则表达式库的使用。
