# Lab1 report

## 2019-10-09:16:26

操作系统课上，练习 1 完成。

以前只写过简单的 makefile，这个 makefile 看了很久。。。

实践证明以后分析这玩意就一顿 warning 输出就完事了。

## 2019-10-11:19:35

练习 2 完成。

实践证明 gdb 也不是很靠谱，BIOS 的第一条指令被反汇编成了 `ljmp 0x3630, 0xf000e05b`，看了半天才发现。。。

这里在开始写练习 2 记录的时候想了一会，问了一下同学，他说他的反汇编正常并认为我的 gdb 有问题，但是我在 wsl、virtualbox、aliyunecs 等多个 ubuntu1804 环境下测试后结果都相同，并未找到问题所在。

过了一天后我在 stackoverflow 上搜了一下[关于 gdb 反汇编 16 位指令的问题](https://stackoverflow.com/questions/32955887/how-to-disassemble-16-bit-x86-boot-sector-code-in-gdb-with-x-i-pc-it-gets-tr/32960272)，发现其他人也有相关问题。其中有一个回答给出了一个 target.xml 文件，指出在 gdb 中使用命令 set tdesc filename target.xml 覆盖 gdb 的设置。经测试，此方法确实可以调整反汇编出 `ljmp $0xf000,$0xe05b` 命令。给出此文件的人认为是 gdb 新版本处理的问题，具体原因等我写完所有实验再探究一下。

## 2019-10-12:16:45

练习 3 完成。

难度不是很大，主要就是查了一些汇编以及关于 GDT 表的内容。

觉得其中比较花时间的就是在描述符格式中，除段基址和段界限外的段属性中，有一个 DC 位。在数据段中它标志段的扩展方向，在代码段中标志段的一致性。

- 数据段中，DC 位为 0 表示缺省的向上扩展，置 1 则表示向下扩展。向上扩展理解起来很简单，寻址范围就是 base ~ base + limit（limit 为段长减 1），对于向下扩展开始不是很理解，网上查了一下，下表为映射到同一段内存区域时两种扩展方式的各种值，其中 LA 即 linear address，length 即段长。定义模数 Modulus，对于段属性中的 Sz 位为 0 即 16 位，模数为 $2^{16}$ = 64KB，置 1 即 32 位，模数为 $2^{32}$ = 4GB。

  | type            | expand up  | expand down            |
  | --------------- | ---------- | ---------------------- |
  | GDT/LDT Base    | LA         | LA + Length - Modulus  |
  | GDT/LDT Limit   | Length - 1 | (Modulus - 1) - Length |
  | Smallest Offset | 0          | Modulus - Length       |
  | Largest Offset  | Length - 1 | Modulus - 1            |
  | Initial ESP     | Length     | 0                      |

  通过此表，可以得出，对于向下扩展的描述符，计算段的地址范围，即为 base + limit + 1 ~ base + limit + length。由此发现，当长度趋近于 Modulus 时，两种扩展模式趋向于相等。因此 intel 定义当向下扩展到最大长度时，无有效偏移。另一种情况下，当 limit 值为 64KB - 1 ~ 1MB - 1 含两端，向下扩展的段无有效偏移。

  向上扩展的最小偏移为 0 ，最大偏移取决于段长度；向下扩展的最大偏移为 0ffffh (16-bit) 或 0ffffffffh (32-bit)，而起始偏移取决于段长度。由此就可以想到以向下扩展数据段作为栈的好处，当栈的空间不够，可以将数据迁移到更大的数据区的顶部，同时将堆栈寄存器指向新位置，此时栈上相对于栈底的相对地址不变。

- 代码段中，DC 位描述了代码段的一致性。
  - DC 位为 0 时，表示非一致性，即调用方 CPL 必须等于描述符 DPL；无论选择子中的 RPL 如何，目标代码都将以与调用方 CPL 相等的 CPL 运行；选择子 RPL 必须小于等于调用方 CPL。
  - DC 位为 1 时，表示代码段一致性，即调用方 CPL 必须大于或等于描述符 DPL（权限低）；目标代码将以与调用方 CPL 相同的 CPL 运行，与选择子 RPL 无关。
  - 直接访问代码段不会改变 CPL。

## 2019-10-14:20:20

练习 4 完成。

比之前的都简单一些，毕竟只需要看懂 C 代码就行，内联汇编之前不太熟，这次简单学了一下。

再就是 readsect 函数中的 `va -= offset % SECTSIZE`，考虑到 offset 不是扇区大小整数倍的问题，~~虽然实际加载的时候并没有用到~~。

最后就是在加载完内核文件后调用内核入口函数的时候进行了一个 `& 0xFFFFFF` 操作，使得链接地址和加载地址开始不同。~~之前只知道不同但是不知道是怎么操作的。~~

## 2019-10-15:14:45

练习 5 完成，很简单，就按照注释提示写就行。

## 2019-10-15:18:16

练习 6 完成，比较简单，看懂代码和注释就行。

## 2019-10-16:16:32

challenge 完成。

主要就是要看明白参考资料里的 `中断与异常、lab1中对中断的处理实现`。

还有就是内联汇编。。。写的很慢，还好没几行

**在存储 idt 表项的 vector.S 中，有的表项有指令 `push $0` 而有的没有。这是因为这一条指令是将 trapframe 结构体中的 error_code 压栈，而对于没有对应错误码的 trap 就用 0 代替。~~本来还没想到这一点，助教问到我才想到 我 tcl~~**
