# 分层的二进制代码作者识别

> [OBA2: An Onion Approach to Binary Code Authorship Attribution]()

## 文章概要

作者分析是恶意软件取证的一个重要研究方向。分析的成功与否取决于逆向工程师的技能与软件的复杂度。本文旨在设计可靠自动的恶意软件作者归因工具以帮助逆向逆向工程师完成这一工作。现有的研究中 (Rosenblum 等人) 已经使用经机器学习排序筛选的特征作为表征程序作者身份的可靠依据。然而，我们的分析表明，以现有方法选出的特征并不都与作者编程风格相关。因此，我们提出了一个二进制作者身份识别的分层技术，OBA2，基于三个互补的层面：预处理、基于语法的归因、基于语义的归因。实验表明我们提出的方法在作者识别中有更高的准确率。

### 引言

现有的软件作者身份识别依赖于从程序源代码中提取的特征。这些方法很难应用到难以获取源码的恶意代码中。此前唯一的二进制层面的作者身份识别是 Rosenblum 等人利用机器学习技术将作者身份与程序中语法特征联系起来，以下称为 IAPB 技术。IAPB 使用的特征是从预定义的模板中获取的，根据训练阶段特征与作者身份的关联性将特征排序。实验表明，排名靠前的特征对于每个作者都是不同的，因此它们假设这些特征能够成功捕获作者的编程风格。但是，我们的研究发展，IPAB 得出的结论过于乐观了。很多排名靠前的特征并不与作者编程风格相关，如编译器生成的包含随机（因此是唯一的）数字的标识符或函数名。这些显然不能反映编程风格。

#### 研究动机

作为二进制作者身份识别的开创性研究，IAPB 的一些理论有助于我们理解作者身份分析。然而，仍存在以下不足：

- 现有的 IAPB 技术无法很好地解决作者编程风格无关的特征过滤问题。
- IAPB 的特征模板提取的特征，如指令序列，无法体现程序语义，可能会误导分析结果。
- IAPB 将特征的唯一性等同于作者风格，而独特的特征并不都与作者风格相关。

#### 贡献

- 我们提出了 OBA2，一种分层方法，结合了过滤无关代码技术的预处理层（Stuttering Layer, SL）、基于语法归因的代码分析层（Code Analysis Layer, CAL）和基于语义归因的寄存器流分析层（Register Flow Analysis Layer, RFAL）以实现有效的作者身份识别。	
- SL 层，我们设计了基于签名的自动探测库函数和其他已知的与作者风格无关函数的技术。
- CAL 层，我们给出了为每个作者建立个人资料，二进制语法到源码的映射。
- RFAL 层，我们设计了新的模型，称为寄存器流图，以捕获语义特征，表示寄存器被操作的方式。

### IAPB

本节简要回顾了 IAPB 技术。

- IAPB 技术使用预定义的特征模板提取二进制程序中的特征。
  - Idioms，短指令序列。
  - Graphlets，CFG 的三节点子图。
  - Subpergraphlets，折叠合并 CFG 中相邻结点得到。
  - Libcalls 和 Call Graphlets，库函数调用。
  - N-grams，字节或指令序列。
- 特征提取后，以一组已知作者的二进制程序作为训练集，对特征排序，排名靠前的作为作者识别的依据。

### OBA2 方法论

#### Stuttering Layer

逆向工程的一个重要的初始步骤就是区分用户代码和库代码。IDA Pro 具有识别代码序列和标准库函数的功能，用于识别由编译器生成的代码，如静态链接的库函数和初始化代码等。SL 包括以下步骤：

- 解析库以提取函数原型、API 数据结构以及类型信息，有助于识别函数调用约定和参数。
- 为库中的导出函数创建签名，基于字节序列、函数大小以及函数实现中的特征如常量、字符串、导入和调用的函数。计算所有的库和函数的签名。
- 将签名应用到反汇编代码的函数调用列表中，进行签名匹配，标记库函数调用。
- 将识别出的库函数从函数列表中溢出，用户代码则用于进一步分析。

#### Code Analysis Layer

很多编程风格会体现在代码语法中，如作者习惯用 for 还是 while 循环，用 if 还是用 switch 等等。如果这类习惯重要到足以将作者与其他人区分开，并将作者编写的不同程序关联起来，那么这些习惯就会成为由代码语法体现的作者的风格。

CAL 层的主要挑战就是从二进制重建源代码层面的语法。因此，我们创建了一个语法模板库（Syntax Template Library, STL）将 C++ 关键字匹配到汇编指令。如 for 循环往往对应着 `cmp-jg-xor-jmp` 的汇编指令序列，if 语句对应 `mov-cmp-jnz-mov-jmp` 的汇编指令。当然并不总是能够精确匹配，后面会提到如何处理精确和不精确匹配。

- STL 用于捕获作者在编程中的选择，如 if 或 switch，他们的相对出现频次会反映不同层次的作者风格。STL 捕获算法的选择、API 和 IO 设备的是哟个，加密算法类型、套接字类型等特征。通过 STL 的使用可以标记作者风格相关的代码。
- 精确匹配，以基本块为单位，基于 hash 函数的匹配。

- 非精确匹配，不完全相同但相似的代码，通过构造特征向量，计算相似性函数。
- 对每个作者建立语法资料 SAP，包括语义类型、创建和调用函数的风格以及程序复杂性。这些数据会用于作者归因任务如分类和聚类。

#### Register Flow Analysis Layer

寄存器流图，用于捕获基于代码语义的编程风格，即寄存器操作方式。

- 构造寄存器流图
  - 统计比较指令数量
  - 记录每个比较指令使用的寄存器
  - 检查每个寄存器从开始到比较指令的流。
  - 将寄存器的变化分类。根据指令分类
    - 堆栈 `push, pop`
    - 算术 `add, sub, mul, div, imul, idiv`
    - 逻辑 `or, and, xor, test, shl`
    - 普通 `mov, lea, call, jmp, jle`
  - 构造寄存器状态图，按照分类重塑状态图，通过计算比较操作数及其分类的哈希来构造 RFG 向量。
- 将 RFG 应用到作者归因
  - 将编程风格识别问题转换为基于两个比较类型指令之间差异构建有值类系统。

### 评估

将 OBA2 的作者归因技术应用到 Google Code Jam 的样本中，相比于 IAPB 准确率有了很大提升。

- SL 层去除了与风格无关的函数
- OBA2 基于大型汇编代码数据库运行，以自动检测语法模板并相应更新作者的资料。
- RFAL 和 CAL 准确率高出 IAPB 中使用的特征。

### 局限性

- 仅针对未混淆的二进制代码
- 需要大量训练集
- 作者数量增加导致准确率降低
- 没有测试不同编译器的影响
- 没有测试其他编程语言