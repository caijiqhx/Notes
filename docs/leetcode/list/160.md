# 160.相交链表 (Easy)

## 题目描述

编写程序，找到两个单链表相交的起始节点。

### 示例

> 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
> 
> 输出：Reference of the node with value = 8
> 
> 输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。

```
A:         a1 -> a2 
                   ↘
                     c1 -> c2 -> c3
                   ↗   
B:   b1 -> b2 -> b3
```

### 注意

- 如果两个链表没有交点，返回 null.
- 在返回结果后，两个链表仍须保持原有的结构。
- 可假定整个链表结构中没有循环。
- 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。

## 代码

### 方法一

较长的链表先走一段距离，之后两个链表同步遍历，当二者指向的 ListNode 相同时即可返回。

```c++
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        int l1 = 0, l2 = 0;
        ListNode *p1 = headA;
        while(p1 != nullptr) {
            p1 = p1->next;
            l1++;
        };
        ListNode *p2 = headB;
        while(p2 != nullptr) {
            p2 = p2->next;
            l2++;
        };
        p1 = headA, p2 = headB;
        int cnt = 0;
        if(l2 > l1) {
            cnt = l2 - l1;
            while(cnt--) {
                p2 = p2->next;
            };
            while(p1 != p2) {
                p1 = p1->next;
                p2 = p2->next;
            };
            if(p1 != nullptr) {
                return p1;
            };
        }else {
            cnt = l1 - l2;
            while(cnt--) {
                p1 = p1->next;
            };
            while(p1 != p2) {
                p1 = p1->next;
                p2 = p2->next;
            };
            if(p1 != nullptr) {
                return p1;
            }
        }
        return nullptr;
    }
};
```

> 执行用时：52ms
> 
> 内存消耗：16.9MB

### 方法二

方法一的代码很长还很丑，换一种思路。

链表 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度。可知 a + c + b = b + c + a。

遍历 A 的指针到尾部时，从 B 开头遍历 B；同样的，遍历 B 的指针到尾部时，从 A 开头遍历 A。这样可以保证两个指针同时到达交点。

```c++
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode *p1 = headA;
        ListNode *p2 = headB;
        while(p1 != p2) {
            p1 = (p1 == nullptr) ? headB : p1->next;
            p2 = (p2 == nullptr) ? headA : p2->next;
        }
        return p1;
    }
};
```

> 执行用时：48ms
> 
> 内存消耗：16.9MB

比方法一快一点，主要是代码短。